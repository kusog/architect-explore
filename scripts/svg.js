/**
 * Allow navigation through a collection of svg diagrams as well as toggling the visibility of sections of the svg diagram
 * that have id attributes.  This version of the library is tuned towards svg files generated by illustrator, especially illustrator
 * putting id attributes of layers based on the name of the layer.  This makes it easy to group a set of elements into a common parent with 
 * the the id.
 * 
 * To support lines that connect various elements in the svg and can hide/show based on the connected element, this code
 * assumes each line is in a layer with an id that has a pattern of "line[num]" such as "line1", "line2", "line55" and that 
 * the layer includes another other line artifacts like arrow heads or various annotations.
 * 
 * This is hacky, get it done, jquery driven javascript.
 * Exposes a core method on window named setupSvgSystem to get the functionality started.
 */
(function() {
    var unique = 1;
    var setHash = false;
    var maxLines = 1500;
    var svgMap, svgHandlers;
    var currentSvgId;
    var lineId = "line";
    var paddingSize = 1000;
    var sizeFactor = 0;//117;
    var nodocsFor = ['Lines']; //ids of <g> elements that we dont even want to try and get docs on.

    var player = {
        isActive: false,
        scriptTimer: null,
        stepDefaultTime: 4000,
        transitionTime: 800,
        scriptType: 2, //0 = just play through script using timers given, 1=pause of first step only, then play auto after that, 2=pause on each step
        playMode: 2,
        currentStep: 0
    };
    
    var defaultTitle = "SVG Explorer";

    /**
     * internal method to render an svg and get its elements setup properly for interaction within the app.
     * 
     * @param {string} svgId 
     * @param {number} zoomType 0 = noZoom, 1 = zoomIn, 2= zoomOut
     */
    function showSvg(svgId, zoomType) {
        var oldSvgDom = $(".svgarea"), 
            newSvgDom;
            parts = svgId.split("/");

        if(parts.length > 1) {
            svgId = parts[0];
        }
        if(!svgId) {
            svgId = "main";
        }
        
        function setup() {
            window.document.title = svgMap[svgId].title ? svgMap[svgId].title : defaultTitle;
            oldSvgDom.remove();
            newSvgDom.removeClass("activeanime");
            if(svgHandlers[svgId]) {
                svgHandlers[svgId]();
            }
            setupScrollPos(newSvgDom);
        }

        function setupSvgVisibleArea(areaId) {
            if(areaId) {
                $("button[data-id='" + areaId + "']").click();            
            }
            else {
                 toggleAll();
            }
        }


        if(svgId != currentSvgId) {
            currentSvgId = svgId;
            $(".buttonGroup").addClass("inactive").removeClass("active");

            if(zoomType) {
                $(".svgarea").addClass("activeanime " + (zoomType==1?"zoomAway":"zoomBack"));
                window.setTimeout(setup, 500);
            }
    
            $.get(svgMap[svgId].svg, function(resp,s,x) {
                //because styles loaded via svg dom structures are not scoped to that svg, we need to ensure
                //all styles generated map into a unique class name.  This code makes assuptions about the
                //css names used in the svg which is derived from how adobe illustrator names css.
                var svg = x.responseText.replace(/cls-/g, "cls"+(unique++)+"-");
                if(svgId == "mainx") {
                    svg = svg.replace(/(<polygon[\w\W]+?)points=(["'])([\.\d, ]+?)(["'])/g, "$1d=$2M$3z$4")
                    // dont close path for polyline
                    .replace(/(<polyline[\w\W]+?)points=(["'])([\.\d, ]+?)(["'])/g, "$1d=$2M$3$4")
                    .replace(/poly(gon|line)/g, "path");
                    //.replace(/<\/svg>/g, '<circle r="8" fill="#529fd9"><animateMotion id="xer" dur="1.6s" repeatCount="indefinite"><mpath xlink:href="#tester"></mpath></animateMotion></circle></svg>');;
                    //.replace(/<\/svg>/g, '<circle id="c1" r="8" fill="#529fd9"><animateMotion id="xer" dur="1.6s" repeatCount="indefinite" path="M956.03, 559.37, 956.03, 676.65, 639.31, 676.65, 639.31, 752.77, 630.03, 752.77"></animateMotion></circle></svg>');;
                }
                newSvgDom = $("<div class='svgarea " + (zoomType == 1 ? "activeanime zoomBack" : zoomType==2? "activeanime zoomAway" : "") + "'><div class='svginner astable'></div></div>");
                newSvgDom.find(".svginner").html(svg);


                if(zoomType == 1) {
                    $(".svgparent").prepend(newSvgDom);
                }
                else {
                    $(".svgparent").append(newSvgDom);
                }

                newSvgDom.on("scroll", function(){
                    var $this = $(this)
                    if(!player.isActive) {
                        window.localStorage[currentSvgId + "_x"] = $this.scrollLeft();
                        window.localStorage[currentSvgId + "_y"] = $this.scrollTop();
                    }
                    var factor = getCalculatedScaleFactor($this, true);// 1000/$this.width();
                    var pad = player.isActive?paddingSize-sizeFactor:0;
                    $("#scrollXPos").val(Math.round(($this.scrollLeft()-paddingSize)*factor));
                    $("#scrollYPos").val(Math.round(($this.scrollTop()-paddingSize)*factor));
                });
        
                var zoomLevel = window.localStorage[currentSvgId + "zoomLevel"];
                if(!zoomLevel) {
                    zoomLevel = 1;
                }
                $("#zoomLevel").val(zoomLevel);
                setupZoom(zoomLevel, newSvgDom.find("svg"));
    
                $("#" + svgId + "Buttons .toggler").addClass("active").each(function() {
                    $("#"+$(this).data("id")).addClass("corearea");
                });

                //Setup logical groups of connector lines in svg to class names.  Some lines have multiple logical line grouping associations.
                //first, all connector lines are connector css class.
                var missing = 0;
                for(var c = 1; c <= maxLines && missing < 5; c++) {
                    missing += $("#" + lineId +c).addClass("connector").length?0:1;
                }
                var groups = svgMap[svgId].groups;
                if(groups) {
                    for(var groupName in groups) {
                        var group = groups[groupName];
                        group.forEach(function(element) {
                            var params = [groupName].concat(element);
                            defineLineGroup.apply(null, params);
                        });
                    }
                }
                setupSvgNavs(svgId);
                var lineAssociations = svgMap[svgId].lineAssociations;
                if(lineAssociations) {
                    lineAssociations.forEach(function(item) {
                        $("#" + item.id).addClass("line-association").data("others", item.others);
                    });
                }

                if(parts.length > 1) {
                    setupSvgVisibleArea(parts[1]);
                    //$("button[data-id='" + parts[1] + "']").click();
                }

                $("#" + svgId + "Buttons .togglerLite").addClass("active").each(function() {
                    var key = "tl_"+this.id;
                    if(window.localStorage[key]) {
                        $(this).click();
                    }
                });

                //Add info icons to items as defined
                var tags = svgMap[svgId].tags;
                if(tags) {
                    var linIds = svgMap[svgId].tags.info;
                    if(linIds) {
                        linIds.forEach(function(linId){
                            var lin = newSvgDom.find(linId + " > line"),
                                x = lin.attr("x2"),
                                y = lin.attr("y2");
                            if(lin.length == 0) {
                                lin = newSvgDom.find(linId + " > polyline");
                                if(lin.length) {
                                    x = lin[0].points[0].x + 3;
                                    y = lin[0].points[0].y + 3;
                                }
                            }
                            if(lin.length == 0) {
                                lin = newSvgDom.find(linId + " > rect");
                                if(lin.length) {
                                    x = lin[0].x.baseVal.value +3;
                                    y = lin[0].y.baseVal.value +3;
                                }
                            }

                            var txtElem = $(document.createElementNS("http://www.w3.org/2000/svg", "use")).attr({
                                class: "svg-infoicon",
                                x: x, y: y,
                                width: 10, height: 10
                            }).data("id", linId.substr(1));
                            txtElem[0].setAttributeNS("http://www.w3.org/1999/xlink", "xlink:href", "/fontawsome/fa-solid.svg#info-circle");
                            newSvgDom.find(linId).append(txtElem);
                        });
                    }
                }
                //---------------------------------


                $("#" + svgId + "Buttons").removeClass("inactive").addClass("active");

                window.setTimeout(function() {
                    newSvgDom.removeClass("zoomBack zoomAway");
                },25);
                if(zoomType) {
                }
                else {
                    setup();
                }
            });
        }
        else {
            setupSvgVisibleArea(parts[1]);
        }                
    }


    /**
     * This needs to be called once per page load to initiate the svg system with known css class names and ids.  Without calling
     * this, the svg diagram system will not function.
     * 
     * @param {object} map optional collection of predefined, read-only, animation scripts to populate the script collection with.
     * @param {object} handlers optional collection of javascript functions that match animation script ids which help to setup the svg once loaded.
     */
    window.setupSvgSystem = function(map, handlers) {        
        svgMap = map;
        svgHandlers = handlers?handlers : {};

        window.addEventListener("hashchange", function(event) {
            if(setHash) {
                setHash = false;
                return;
            }
            var name = window.location.hash.substr(1),
                parts = name.split("/");
            if(parts.length > 0 && parts[0].length > 0) {
                showSvg(name, 1);
            }
            else {
                showSvg(name, 2);
            }
        }, false);
        $(".goBack").click(function() {
            window.location.hash = "";
        });

        $("#hideBg").click(function() {
            var transitionTime = "500ms";
            $(".corearea").each(function() {
                var bgRect = $(this).find("> rect"),
                    bgLabel = $(this).find("> text"),
                    fill = bgRect.css("fill"),
                    oldFill = bgRect.data("fill");
                
                if(oldFill) {
                    bgRect.css("fill", oldFill);
                    bgRect.data("fill", null);
                    bgLabel.show(transitionTime);
                }
                else {
                    bgRect.data("fill", fill);
                    bgRect.css("fill", "transparent");
                    bgLabel.hide(transitionTime);
                }
            });
        });

        $("#makeScript").click(function() {
            if(!$("#scriptTool").toggle().is(':visible')) {
                //$("#stopScript").click();
            }
        });
        $("#zoomLevel").on("input", function() {
            setupZoom(this.value);
        });
        $("#resetZoom").click(function() {
            var dom = $(".svgarea svg");
            $("#zoomLevel").val(1);

            dom.width(player.isActive ? getSvgNaturalWidth(dom) : "");
            window.localStorage.removeItem(currentSvgId + "zoomLevel");
            window.localStorage.removeItem(currentSvgId + "_x");
            window.localStorage.removeItem(currentSvgId + "_y");
            $("#zoomInfo, #scrollXPos, #scrollYPos").val("");
        });

        $("#hideLinks").click(function() {
            $(".txtLink").toggleClass("hidesvg");
        });

        //Will connect to buttons that toggle the visibility of a given svg group id and all the connector lines 
        //connected to it.  Note that this has to keep track of lines being hidden by other svg groups that are also
        //connected to them.  That is what hideCount is used for.
        $(".toggler").click(function() {
            var button = $(this);
            var main = $("#"+ button.data("id"));
            main.toggleClass("hidesvg");
            var hiding = main.hasClass("hidesvg");

            if(hiding) {
                button.removeClass("active");
            }
            else {
                button.addClass("active");
            }

            $(button.data("others")).each(function() {
                var count = $(this).data("hideCount");
                if(hiding) {
                    $(this).data("hideCount", count?++count:1).addClass("hidesvg");
                }
                else {
                    $(this).data("hideCount", count?--count:1);
                    if(count < 1) {
                        $(this).removeClass("hidesvg");
                    }
                }
            });
        });

        $(".togglerLite").click(function() {
            $(this).toggleClass("active");
            var key = "tl_"+this.id;
            if(!$(this).hasClass("active")) {
                window.localStorage[key] = "off";
            }
            else {
                window.localStorage.removeItem(key);
            }
        });

        $("body").on("click", "g[id]", function(event) {
            if($(".svgparent").hasClass("set-highlight")) {
                $(this).toggleClass("highlight");
                event.stopPropagation();
            }
        });

        $(window).resize(function(){
            $(".svgarea svg").data("w",null);
        });

        $("#highlighMode").click(function() {
            $(".svgparent").toggleClass("set-highlight");
        });

        //Follows are High level absolute sets of visibility to be show while everything else hides.
        //These buttons are used to get the svg groups into a known visibility state based
        //on the desired set of groups to be shown.

        $(".cmd").click(function() {
            var newName,
                oldName = window.location.hash.substr(1);
            showSvgGroups($(this).data("groups").split(","));
            var hashParts = oldName.split("/");
            var name = hashParts.length?hashParts[0]:"";
            if($(this).data("id")) {
                newName = name + "/" + $(this).data("id");
            }
            else {
                newName = name;
            }
            if(newName != oldName) {
                setHash = true;
                window.location.hash = newName;
            }
        });

        $("#showAll").click(function() {
            var hashParts = window.location.hash.substr(1).split("/");
            var name = hashParts.length?hashParts[0]:"";

            if(name != window.location.hash.substr(1)) {
                setHash=true;
                window.location.hash = name;
            }
            toggleAll();
        });

        $("body").on("mouseenter", ".note-contents .note", function() {
            $(this).parent().draggable('disable').resizable('disable');
        }).on("mouseleave", ".note-contents .note", function() {
            $(this).parent().draggable('enable').resizable('enable');
        });
        $("#startScript").click(function() {
            player.playScript(player.activeScript, $("#autoPlay .active").data("val"));
        });
        $("#stopScript").click(function() {
            player.stopScript();
        });
        $("#nextStep").click(function() {
            moveNextScriptStep(false);
        });
        $("#prevStep").click(function() {
            moveNextScriptStep(true);
        });

        $(".script-level-fields input").on("change", function() {
            player.activeScript.name = $("#scriptName").val();
            player.activeScript.defaultTime = $("#scriptDefTime").val();
            replaceLocalScript();
        });

        $("#addStep").click(function() {
            updateCurrentScriptStep();
            player.activeScript.steps.splice(player.currentStep, 0, $.extend({},player.activeScript.steps[player.currentStep]));
            replaceLocalScript();
            $("#totalSteps").text(player.activeScript.steps.length);
            player.setupFromStep(player.currentStep+1);
        });

        $("#deleteStep").click(function() {
            var script = player.activeScript;
            if(script.steps.length && player.currentStep < script.steps.length) {
                script.steps.splice(player.currentStep,1);
                replaceLocalScript();
                $("#totalSteps").text(player.activeScript.steps.length);
                player.setupFromStep(player.currentStep);
            }
        });

        $("#setScriptStepState").click(function() {
            updateCurrentScriptStep();
        });

        var ctrlHover = [];
        $("body").on("click", ".svgarea svg g, .svgarea svg .svg-infoicon", function(event) {
            var id = this.id;
            if(!id) {
                id = $(this).data("id");
                event.stopPropagation();
            }
            if(id && nodocsFor.indexOf(id) == -1) {
                $.get("/docs/" + currentSvgId + "." + id + ".html").then(function(html) {
                    $("#itemDocs").addClass("active").find(".content").html(html);
                });
            }
        }).on("click", ".closeItemDocs", function() {
            $("#itemDocs").removeClass("active");
        }).on("mouseenter", ".connector", function(event) {
            if(this.attributes["title"]) {
                if (event.ctrlKey) {
                    var key = this.attributes["title"].value;
                    if(ctrlHover.indexOf(key) == -1) {
                        ctrlHover.push(key);
                        console.log(ctrlHover.sort().join(","));
                    }
                }
                else {
                    ctrlHover = [];
                }
            }
        });

        $("body").on("mouseenter", ".line-association > *", function() {
            $(".connector").addClass("subdued");
            $($(this).parent().data("others")).removeClass("subdued").addClass("spot");

        }).on("mouseout", ".line-association > *", function() {
            $(".connector").removeClass("subdued spot");
        });

        function updateCurrentScriptStep() {
            var step = player.activeScript.steps[player.currentStep];
            step.url = window.location.hash.split('/')[0];
            step.url = step.url ? step.url : "#";

            step.zoom = Number($("#zoomInfo").val());
            step.scroll = {x: Number($("#scrollXPos").val()), y: Number($("#scrollYPos").val())};
            var val = $("#stepPlayTime").val();
            step.time = val?Number(val) : null;
            val = $("#stepTransTime").val();
            step.transitionTime = val?Number(val) : null;

            var showItems = [];
            $(".buttonGroup.active .toggler").each(function() {
                if($(this).hasClass("active")) {
                    showItems.push($(this).data("id"));
                }    
            });
            step.show = showItems.join(",");
            var factor = getCalculatedScaleFactor(null, true),
                nc = $(".note-contents1"),
                ncPos = nc.position();
            ncPos.left = Math.round((ncPos.left - paddingSize)*factor);
            ncPos.top = Math.round((ncPos.top - paddingSize)*factor);
            step.notes = [{
                text: nc.find(".note").html(),
                pos: ncPos,
                size: {width: nc.outerWidth(), height: nc.outerHeight()}
            }];

            var highlight = [];
            $(".svgparent .highlight").each(function() {
                highlight.push("#" + this.id);
            });
            step.highlight = highlight.join(",");

            replaceLocalScript();
        }

        function replaceLocalScript() {
            var script = player.activeScript;
            if(window.localStorage.scripts) {
                var localScripts = JSON.parse(window.localStorage.scripts);
                for(var i = 0; i < localScripts.length;i++) {
                    if(localScripts[i].id == player.activeScript.id) {
                        localScripts[i] = player.activeScript;
                        window.localStorage.scripts = JSON.stringify(localScripts);
                        return true;
                    }
                }
            }
        }

        $("#scripts").change(function() {
            var op = $(this).val();
            if(op) {
                $(".script-tools-req").show();
                if(op != "new") {
                    player.playScript(player.scripts[$(this).val()],2);
                }
                else {
                    var script = {
                        id: getUniqueScriptId(),
                        name: "New Script",
                        steps:[{}]
                    };
                    player.scripts.push(script);
                    var localScripts = [];
                    if(window.localStorage.scripts) {
                        var localScripts = JSON.parse(window.localStorage.scripts);
                    }
                    localScripts.push(script);
                    window.localStorage.scripts = JSON.stringify(localScripts);

                    var index = player.scripts.length -1;
                    $("#scripts").append("<option value='" + index + "' >"+script.name+"</option>").val(index);
                    player.playScript(script);

                }
            }
            else {
                $(".script-tools-req").hide();
                player.stopScript();
            }
        });

        $("#autoPlay").click(function() {
            var active = Number($("#autoPlay span.active").data("val")) +2;
            if(active > 3) {
                active = 1;
            }
            $("#autoPlay span").removeClass("active");
            $("#autoPlay span:nth-child("+active+")").addClass("active");
        });

        //Setup code when this svg library is first setup on the page.
        if(window.location.hash) {
            showSvg(window.location.hash.substr(1));
        }
        else {
            showSvg("main");
        }
    };

    window.setupScripts = function(scripts) {
        player.scripts = scripts;
        if(window.localStorage.scripts) {
            var localScripts = JSON.parse(window.localStorage.scripts);
            player.scripts.push.apply(player.scripts,localScripts);
        }
        addScriptsToDropdown(player.scripts);
    };

    function addScriptsToDropdown(scripts) {
        scripts.forEach(function(script, index) {
            var name = script.name ? script.name : "Unnamed Script";
            $("#scripts").append("<option value='" + index + "' >"+name+"</option>");
        });
    }

    /**
     * 
     * @param {object definiting steps for script to play} script 
     */
    player.playScript = function(script, playMode) {
        if(playMode === undefined) {
            playMode = player.scriptType;
        }
        player.playSpeed = playMode;
        $("#autoPlay span").removeClass("active");
        $("#autoPlay span:nth-child("+(playMode+1)+")").addClass("active");
        function setupFromStep(index) {
            if(index < 0 || index >= script.steps.length) {
                return ;
            }

            player.currentStep = index;
            var step = script.steps[index];
            if(step.url && window.location.hash != step.url.substr(1)) {
                window.location.hash=step.url;
                window.setTimeout(realSetup, 1000);
            }
            else {
                realSetup();
            }

            function realSetup() {
                $("#currentStep").text(index+1);
                var animeSpeed = script.hasOwnProperty("defaultTransitionTime") ? script.defaultTransitionTime :  player.transitionTime;
                var animeInfo = {};
                if(step.hasOwnProperty("transitionTime") && step.transitionTime !== null) {
                    animeSpeed = step.transitionTime;
                    $("#stepTransTime").val(animeSpeed);
                }
                else {
                    $("#stepTransTime").val("");
                }
                if(step.hasOwnProperty("time") && step.time !== null) {
                    $("#stepPlayTime").val(step.time);
                }
                else {
                    $("#stepPlayTime").val("");
                }

                if(step.zoom) {
                    var width = setupZoom(step.zoom, null, animeSpeed),
                        height = width * $(".svgarea").width()/$(".svgarea").height();
                    //$(".svgarea").css({width: width, height: height+"px"});
                }
                if(step.scroll) {
                    var factor = getCalculatedScaleFactor();//   $(".svgarea").width()/1000;
                    animeInfo.scrollTop = ((factor*step.scroll.y) + paddingSize) + "px";
                    animeInfo.scrollLeft = ((factor*step.scroll.x) + paddingSize) + "px";
                }

                $(".svgarea .note-contents").remove();
                $(".svgarea").animate(animeInfo, animeSpeed, "linear", function(){
                    if(step.notes) {
                        var factor = getCalculatedScaleFactor();
                        if(typeof(step.notes) == "string") {
                            $(".note-contents1 .note").html(step.notes).parent().show();
                        }
                        else {
                            step.notes.forEach(function(note, i){
                                var cnr = $(".note-clone").clone().appendTo(".svgarea .svginner")
                                    .removeClass("note-clone no-content hide").addClass("note-contents" + (i+1))
                                    .css({"top":((factor*note.pos.top) + paddingSize ) + "px", "left":((factor*note.pos.left) + paddingSize) + "px"})
                                    .draggable().resizable()
                                    .find(".note").html(note.text).parent();

                                if(!note.text) {
                                    cnr.addClass("no-content");
                                }
                                if(note.size) {
                                    cnr.css({"width":note.size.width + "px", "height":note.size.height + "px"});
                                }                            
                            });
                        }
                    }
                    else {
                        $(".note-contents1").addClass("no-content").removeClass("hide");
                    }    
                });
                
                if(step.show) {
                    showSvgGroups(step.show.split(","));
                }
                else {
                    $("#showAll").click();
                }

                //old way for highlight
                $(".svgarea svg .active").removeClass("active");
                //new way for highlight
                $(".svgarea svg .highlight").removeClass("highlight");

                if(step.highlight) {
                    if(typeof(step.highlight) == "string") {
                        $(step.highlight).addClass("highlight");
                    }
                    else {
                        if(step.highlight.rect) {
                            var items = step.highlight.rect.split(",");
                            items.forEach(function(item) {
                                $(item + " rect").addClass("active");
                            });
                        }
                        if(step.highlight.line) {
                            var items = step.highlight.line.split(",");
                            items.forEach(function(item) {
                                $(item + " line," + item + " polygon," + item + " polyline").addClass("active");
                            });
                        }
                    }
                }


                function doit(goBackwards, noEnding) {
                        player.scriptTimer = window.setTimeout(function() {
                            if(!goBackwards && index+1 < script.steps.length) {
                                setupFromStep(index+1);
                            }
                            else if(goBackwards && index-1 >= 0) {
                                setupFromStep(index-1);
                            }
                            else if(!noEnding) {
                                player.stopScript();
                            }
                        }, playMode == 2 ? 0 : step.time ? step.time : script.defaultTime ? script.defaultTime : player.stepDefaultTime);
                }


                if(!playMode || (playMode== 1 && index)) {
                    doit();
                }
            }
        }
        player.setupFromStep = setupFromStep;
        player.activeScript = script;

        if(player.scriptTimer) {
            window.clearTimeout(player.scriptTimer);
        }
        if(script && script.steps) {
            $("#scriptName").val(script.name);
            $("#scriptDefTime").val(script.defaultTime);
            $("#totalSteps").html(script.steps.length)
            $("#stopScript,.scriptNav,.active-play-button").show();
            $("#startScript").hide();
            $(".svgparent").parent().addClass("player");
            player.isActive = true;
            setupFromStep(0);
        }

    };

    player.stopScript = function() {
        if(player.scriptTimer) {
            window.clearTimeout(player.scriptTimer);
            player.scriptTimer=null;
        }
        player.currentStep = 0;
        $("#stopScript, .scriptNav,.active-play-button").hide();
        $("#startScript").show();
        $("#resetZoom").click();
        $(".svgparent").removeClass("set-highlight").parent().removeClass("player");
        $(".svgarea svg .active").removeClass("active");
        $(".svgparent .highlight").removeClass("highlight");
        player.isActive = false;
        showSvgGroups();
    };

    function moveNextScriptStep(goBackwards) {
        if(player.setupFromStep) {
            player.setupFromStep(player.currentStep + (goBackwards?-1:1));
        }
    }

    function toggleAll() {
        $(".toggler").each(function() {
            if(!$(this).hasClass("active")) {
                $(this).click();
            }
        });
    }

    function setupSvgNavs(svgId) {
        var navs = svgMap[svgId].navs;
        if(navs) {
            navs.forEach(function(nav) {
                if(nav.css) {
                    $(nav.selector).addClass(nav.css);
                }
                $(nav.selector).css("cursor","pointer").click(function(event) {
                    if(!$(".svgparent").hasClass("set-highlight") && !$(event.target).hasClass("svg-infoicon")) {
                        if(nav.svg) {
                            window.location.hash = nav.svg;
                        }
                        else if(nav.url) {
                            window.location.href = nav.url;
                        }
                        event.stopPropagation();
                        return false;
                    }
                });
            });
        }
    }

    function setupScrollPos(svgArea) {
        var x = window.localStorage[currentSvgId + "_x"],
            y = window.localStorage[currentSvgId + "_y"];
        if(player.isActive) {
            svgArea.scrollTop(paddingSize).scrollLeft(paddingSize);
        }
        else if(x && y) {
            svgArea.scrollTop(y).scrollLeft(x);
        }
    }

    function setupZoom(zoomLevel, dom, animeSpeed) {
        if(!dom) {
            dom = $(".svgarea svg");
        }
        if(!player.isActive) {
            window.localStorage[currentSvgId + "zoomLevel"] = zoomLevel;
        }
        $("#zoomInfo").val(zoomLevel);
        //var trans = "scale("+ zoomLevel +"," + zoomLevel + ")";
        var w = getSvgNaturalWidth(dom);
            
        //dom.css("transform", trans).width(w*zoomLevel).height(h*zoomLevel);
        var zoom = (w*zoomLevel) + "px";
        if(animeSpeed) {
            dom.animate({width: zoom}, animeSpeed, "linear");
        }
        else {
            dom.width(zoom);
        }
        return zoom;
    }

    function getSvgNaturalWidth(svg) {
        var w = svg.data("w");
        if(!w) {
            svg.parent().removeClass("astable");
            svg.data("w", w = svg.width());
            svg.parent().addClass("astable");
        }
        return w;
    }

    /**
     * Based on the width and a multiple of 1000
     */
    function getCalculatedScaleFactor(dom, useDown) {
        if(!dom) {
            dom = $(".svgarea");
        }
        var factor = dom.width()/1000;

        if(useDown) {
            factor = 1000/dom.width();
        }

        return factor;
    }

    /**
     * Will apply the given css class name to svg elements that match the id generated from the numbers passed in
     * This method assumes there are collections of svg elements with ids in a range such as line1, line2, line55.  
     * Either a lower and upper bound are provided for this method or an array of individual numbers is provided.
     * It is often the case that when creating a digram in a tool like adobe illustrator that a group of lines to a common element
     * can have consecutive ids such as 23-26 where that is line23, line24, line25, line26 that matches and would get the provided
     * css class name.
     * @param {string} name The css class name to use for the lines specified
     * @param {Array, number} i1 Either an array of numbers or a single number
     * @param {number} i2 If i1 was a single number, this must be specified as another single number which the two numbers form the boundary of a loop to add the class to the given lines
     * @param {Array} i3 If i1 and i2 are specified as numbers, then this can also be specified as an array
     */
    function defineLineGroup(idPrefix, name, i1, i2, i3) {
        function loopArray(arr) {
            arr.forEach(function(c) {
                $("#" + idPrefix + c).addClass(name).attr("title", c);
            });
        }
        if(typeof(i1) == "number" && typeof(i2) == "number") {
            for(var c = i1; c <= i2; c++) {
                $("#" + idPrefix + c).addClass(name).attr("title", c);
            }
            if(i3) {
                loopArray(i3);
            }
        }
        else {
            loopArray(i1);
        }
    }


    function showSvgGroups(visibleSvgGroupIds) {
        $(".toggler").each(function() {
            if($(this).hasClass("active") && (visibleSvgGroupIds == undefined || visibleSvgGroupIds.indexOf($(this).data("id")) == -1)) {
                $(this).click();
            }
            if((visibleSvgGroupIds == undefined || visibleSvgGroupIds.indexOf($(this).data("id")) != -1) && !$(this).hasClass("active")) {
                $(this).click();
            }
        });
    }

    function getUniqueScriptId() {
        var i = 1;
        for(;;) {
            var id = "N" + i,
                unique = true;
            for(var c = 0; c < player.scripts.length; c++) {
                if(player.scripts[c].id == id) {
                    unique = false;
                    break;
                }
            }
            if(unique) {
                return id;
            }
            i++;
        }
    }
})();